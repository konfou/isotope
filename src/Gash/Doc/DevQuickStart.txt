If you're a C++ developer and you want to become familiar with the source
code to Gash, this doc is for you.  If you want to learn how to write apps
in Gash, read QuickStart.txt

You'll notice there are a couple executables and several libraries:

Gash.exe       - see below
GashGui.exe    - see below

GashEngine.lib - contains the Gash virtual machine, compiler, etc.
GashLib.lib    - contains basic Gash classes
GashQt.lib     - contains Gash classes for doing Qt stuff
GashSdl.lib    - contains Gash classes for doing SDL stuff
GClasses.lib   - contains a bunch of useful C++ classes


Gash.exe and GashGui.exe both do pretty much the same thing.  The main
difference is that one is command-line based and the other has a graphical
user interface.  So if you prefer to work from the command-line, use
Gash.exe and if you prefer a GUI, use GashGui.exe.  Don't worry, there's no
duplicated code.  Both applications are really just wrappers around
GashEngine.lib which is where the real meat is.  There are a few subtle
differences between Gash.exe and GashGui.exe that you should be aware of:

GashGui.exe includes a debugger.  Gash.exe does not.
GashGui.exe supports Qt.  Gash.exe does not.
Gash.exe supports SDL.  GashGui.exe does not.

So if you write an app that uses classes in GashQt.lib, you need to use
GashGui.exe to run it.  If you write an app that uses classes in GashSdl.lib,
you need to use Gash.exe to run it.  Why is there a separation?  Because
the Windows version of Qt won't cooperate with SDL.  I can make the play
nicely together on Linux, but I've decided to support both platforms for
now so that's why.  The debugger uses Qt, so that's why it's only in
to GashGui.exe.

The first thing you probably want to know is how to make a C++ class
accessible to Gash.  (That's the easiest way to extend the capabilities of 
Gash.)  So first let me explain how it works:

When you construct a GashEngine object, you must pass it an object that
inherrits from CallBackGetter.  Later, when the Gash jitter or VM needs to
link a call to a C++ method, it askes the CallBackGetter for a pointer to
the method with the specified signature.  Since you provide the
CallBackGetter, you can use whatever logic you want to find the appropriate
method.  Typically you'll probably want to use the signature as a key to
look up the method in a hash table.  Since that's the common way to do it,
Gash provides a HashTable class that you can use if you want.  Let's take
a look at an existing class to see an example:

Look at GashLibCallBackGetter::GetCallBack in GashLib.h.  The first thing
this method does is check if the HashTable exists yet.  If it doesn't exist
yet, it calls RegisterGashMachineClasses to construct the HashTable and
stuff it full of data.  After the HashTable has been made, it calls
WrapperObject::FindMachineMethod which retrieves the method pointer from
the hash table.  Finally if it doesn't find a suitable method, it calls
GetCallBack on the base class which will then check to see if it knows of
a method with that signature.

Now look at RegisterGashMachineClasses() in MachineObjects.cpp.  Notice that
it just delegates the work of stuffing the hash table to each of the classes.
So for an example, now look at RegisterMImage() in MImage.cpp.  You'll see
that it just adds a bunch of method pointers to the hash table.  Where are
those methods defined?  In MImage.h.  Let's look there next.  You'll notice
that the MImage class inherrits from WrapperObject.  All classes that you
call from Gash must inherrit from WrapperObject.  In this case, the only
reason the MImage class exists is to wrap the GImage class (which does not
inherrit from WrapperObject).  So you'll see that most of the methods in
MImage just call methods in GImage.  Also notice that the method parameters
are mostly of type "EVar*".  An EVar is a Gash variable.

Now the last place to look: go to Image.gash.  Look for a class named "Image".
Actually this isn't a class, it's an interface.  It contains the signatures
of all the methods in the class.  (This is where the Gash engine gets the
signature from.)  And that makes it so you can call into it from Gash code.
So, just use the MImage class as an example and you should be able to figure
out how to make your C++ callable from Gash.

As you can see, this process is a bit hairy.  Eventually I plan to automate
the process of adding a C++ class to be callable from Gash.  If you run
"GashGui GUI", and then click on "I- Import Cpp" it's supposed to do all this
work for you but it doesn't work yet.  It would be REALLY REALLY REALLY
helpful if you wanted to get this thing working cuz then we could just import
tons of useful classes into Gash.

---------------------

Finally, let me point out some useful places in code:

In Error.cpp there's a method named "GotAnError".  This method is called
immediately whenever anything goes wrong (compiler error, runtime error,
syntax parsing error, unhandled exception, etc.)  So this is a great place
to put a breakpoint.

todo: finish this doc