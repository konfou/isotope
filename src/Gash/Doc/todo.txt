Cleanup
--------
Do all the "todo:" spots

IDE
----
redo it
write a function splitter
write code analyzer
don't show imported classes
port to Linux
Make the debugger accessable via sockets or some other non-gui mechanism

Engine
-------
support freeze-dumps
handle abstract classes properly
make instructions 4 bytes
support comments on classes/methods/files
interfaces should put name in xlib file
Add Sleep ASM primitive
Add performance profiling tools for debug mode
Add inline functions
Write an optimizer
Add more useful metadata to disassembler
shorten the number of ops to get a resource string

Project Manager
----------------
Write Source-control center
Write Bug tracking system
Write auto-test checkin system

AI idea thing
--------------
There is a global intelligence level where zero is infinitely easy and some max value can solve a very complex problem.
The intelligence level starts at zero.
A problem is created with a difficulty-level randomely selected between zero and the intelligence level.
The problem is administered to all the cells.
a cell is 'n' bytes of code
execute all cells in paralell
After a long time if no cell solves the problem, the question is thrown out and we try again--this will hurt the average percentage which can bring down the intelligence level.
When any cell solves the problem, the time it took is multiplied by 3 and given to the rest of the cells
When the time is up, five percent of cells that didn't solve the problem are destroyed
The destroyed cells are filled with exact copies or mutated copies of successful cells.
Mutations happen to a small percent of copies and are random, but designed to make executable code
If a cell calls into another cell, that cell becomes its liability. They get copied together (and relinked to each other), but it uses up 2 (or more if there are chains) of that cell's reproduction grants. If that cell is given fewer reproduction grants than in needs for one repro, then it passes the buck.
cells that are reproed because they are called into still retain their individual identity and are given a chance to solve problems. This helps limit parasites because the cell that does the work will be more efficient if the parasite isn't needed.
Cells can write to themselves, but not to other cells. They can read other cells and call into them, but become dependant on them if they do.
Cells can read the problem supplied and write to a supplied answer space.
All illegal operations are ignored and just become time-liabilities to the cell.
Each cell has a cap on the amount of stack-space it is allowed to use. Circular calls will use it up quickly. If a cell uses all of it's stack space, it gets struck dead.
Each cell is a method that takes one parameter which serves as space for both question and answer.
A running average of percentage performance is kept over a constant number of trials. The intelligence level is ajusted after each trial based on the running average. We try to maintain a constant percentage pass rate.
 


I removed $(QTDIR)\lib\qtmain.lib from the linked libraries because it fights with sdlmain.lib.  Apparently there's info about a better way to do this at http://www.libsdl.org/cvs/qtSDL.tar.gz, so read that and do it sometime.

